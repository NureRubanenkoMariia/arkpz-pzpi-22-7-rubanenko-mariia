Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт
з лабораторної роботи №2
з дисципліни «Аналіз та рефакторинг коду»
з теми: «Розробка бази даних для серверної частини програмної системи та прикладного програмного інтерфейсу (АРІ)»





Виконав 								Перевірив
ст. гр. ПЗПІ-22-7 							доц. Сокорчук І. П.
Рубаненко М. С.








2024 рік
РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ
1.1	Мета роботи


Розробити будову програмної системи «Банк крові», включаючи створення UML діаграм для моделювання процесів взаємодії користувачів та компонентів системи, а також ER діаграми для структурування даних і візуалізації їх взаємозв'язків. Окрім цього, передбачається розробка функціональності для роботи з базою даних, що забезпечить збереження та обробку інформації про кровоздачі, запити лікарень та інші важливі процеси. 


1.2	Розробка будови програмної системи


Розроблена будова для програмної системи «Програмна система для управління банками крові та координації донорських процесів». 



1.3	Створення UML діаграми


Діаграма моделює функціонал інформаційної системи для управління банком крові рис.1.1. Система орієнтована на координацію дій між кількома групами користувачів: власниками банків крові, працівниками, донорами, лікарнями, транспортувальниками. 

Рисунок 1.1 – UML -діаграма інформаційної системи «Банк крові»

Всі групи користувачів мають чітко визначені ролі та завдання, які підтримуються через взаємодію з системою:

а)	власник банку крові:
1)	реєстрація працівників банку у системі;
2)	доступ до статистики (поставки, переробка, транспортування);
3)	управління роботою банку крові
б)	працівник банку крові
1)	обробка запитів від лікарень на постачання крові;
2)	обробка постачань крові (підготовка крові до транспортування або зберігання);
3)	призначення транспортувальників для виконання запитів на доставку.
в)	працівник лікарні
1)	реєстрація лікарні як установи в системі
2)	надсилання запитів на постачання крові із зазначенням вимог (група крові, об’єм тощо);
3)	отримання доставленої крові після обробки запитів.
г)	донор
1)	реєстрація в системі з можливістю заповнити медичну карту;
2)	управління профілем (оновлення контактних чи медичних даних):
3)	перегляд історії донорства;
4)	ознайомлення з рекомендаціями щодо харчування та активності після здачі крові;
д)	транспортувальник
1)	отримання завдань на транспортування крові;
2)	забезпечення перевезення крові в спеціальних умовах;
3)	контроль обладнання (холодильників для крові);
е)	працівник технічного обслуговування
1)	технічне обслуговування та оновлення системи;
2)	усунення технічних несправностей.

Щодо функціональних прецедентів, система управління банком крові починається з процесу реєстрації в системі, що є спільним для всіх типів користувачів. Кожен актор, який хоче отримати доступ до функціоналу, повинен створити обліковий запис. Процес реєстрації відрізняється залежно від ролі: донори під час реєстрації заповнюють медичну карту, працівники лікарень вказують тип установи, а працівників банку крові та транспортувальників реєструє власник банку крові. Після реєстрації кожен користувач проходить через процес автентифікації, здійснюючи вхід у систему за допомогою логіна і пароля.
Однією з ключових функцій системи є управління запитами на постачання крові, які надходять від лікарень. Працівники лікарень заповнюють анкету, де вказують специфічні вимоги, такі як група крові, обсяг та терміни доставки. Ці запити обробляються працівниками банку крові, які аналізують їх на предмет відповідності запасам крові та призначають транспортувальників для виконання запиту. Після цього кров готується до транспортування, і відповідальність переходить до транспортувальників.
Окрім обробки запитів, працівники банку крові займаються обробкою постачань крові, що включає її підготовку до зберігання, перевірку якості та документування. Паралельно транспортувальники забезпечують транспортування крові, дотримуючись усіх вимог щодо умов перевезення, таких як контроль температури і вологості за допомогою спеціальних датчиків. У разі відхилень від норм, система повідомляє відповідальних осіб для вжиття необхідних заходів.
Донори, які є джерелом поповнення запасів крові, мають доступ до своїх профілів, де вони можуть переглядати історію донорства, що включає дати здачі крові, обсяг та інші деталі. 
Для власника банку крові передбачений окремий функціонал – він має можливість переглядати статистику щодо роботи системи. Це включає інформацію про кількість оброблених запитів, виконаних постачань, стан запасів крові.

1.4	Створення ER діаграми даних

Перед початком розробки бази даних для системи управління банком крові було створено ER-діаграму для спрощення моделювання структури даних рис.1.2. 
На ER-діаграмі показано взаємозв’язок між наступними сутностями:
	Банк крові (id, назва, email, розташування, контактний телефон);
	Центр донорства крові (id, назва);
	Холодильник для крові (id, назва, місткість);
	Група крові (id, назва, резус-фактор);
	Запаси крові (id, id банку крові, id групи крові, id компонента, дата створення, термін придатності);
	Компонент крові (id, назва, об’єм одного пакету, умови зберігання, термін придатності в днях);
	Запит крові (id, статус, дата запиту, id лікарні, id банку крові);
	Компоненти запиту (id запиту, id компонента, кількість);
	Транзакції з кров’ю (id, тип транзакції, кількість, дата операції);
	Транспортування крові (id, id банку крові, статус);
	Донор (id, id групи крові, контактний телефон);
	Сеанс донорства (id, id донора, кількість крові, дата сеансу);
	Лікарня (id, назва, контактний телефон);
	Поставка крові (id, id центру донорства, id банку крові, дата);
	Деталі поставки (id поставки, id групи крові, id компонента, дата створення, термін придатності);
	Сенсори транспортування (id транспортування, температура, стан).
Для забезпечення цілісності зв'язків створено наступні відношення:
	між Банк крові та Запаси крові: зв’язок один-до-багатьох (кожен банк має власні запаси крові);
	між Група крові та Донор: зв’язок один-до-багатьох (одна група крові може бути у багатьох донорів);
	між Запит крові та Компоненти запиту: зв’язок один-до-багатьох (кожен запит може включати кілька компонентів);
	між Поставка крові та Деталі поставки: зв’язок один-до-багатьох (кожна поставка може містити кілька пакетів крові);
Аналізуючи структуру бази даних, можна зробити висновок, що більшість зв’язків є "один до багатьох", що забезпечує оптимальну організацію даних та їхню інтеграцію між сутностями.


Рисунок 1.2 – ER-діаграма інформаційної системи «Банк крові»

Розглянемо детальніше деякі зв’язки:
	Зв’язок між Запаси крові та Компонент крові: запаси містять конкретні компоненти крові, кожен із яких має визначений об’єм і термін придатності.
	Зв’язок між Запит крові та Лікарня: кожна лікарня може подавати багато запитів на кров.
	Зв’язок між Донор та Сеанс донорства: кожен донор може брати участь у багатьох сеансах донорства, але кожен сеанс прив’язаний до конкретного донора.
Ця структура забезпечує гнучкість та можливість розширення системи, зокрема для додавання нових функціональностей, таких як аналіз ефективності поставок або автоматизація повідомлень для донорів.

1.5	Побудова логічної моделі бази даних на основі ER-діаграми


		Процес проектування логічної моделі бази даних «Система управління банком крові» передбачає вибір реляційної моделі, що є оптимальним рішенням для предметної області. Ця модель найкраще відповідає потребам зберігання, обробки та аналізу структурованих даних, таких як інформація про донорів, запаси крові, запити лікарень, транспортування крові та інші аспекти системи рис.1.3.
Після ретельного аналізу ER-діаграми, було розроблено схему реляційної бази даних, що складається з сімнадцяти таблиць. Для іменування цих таблиць та їх атрибутів була використана англійська мова. Нижче наведено довідник англомовних назв атрибутів:
а)	table «blood_bank» – таблиця «Банк крові» має такі атрибути:
1)	blood_bank_id – ідентифікатор банку крові;first_name – ім’я злочинця;
2)	name – назва банку крові;
3)	email – електронна пошта банку;
4)	location – місце розташування банку крові;
5)	contact_number – контактний номер телефону
6)	user_id – ідентифікатор користувача, власника банку.

б)	table «blood_donation_center» – таблиця «Центр донорства крові» має такі атрибути:
1)	blood_donation_center_id – ідентифікатор центру донорства;
2)	name – назва центру донорства крові.

в)	table «blood_fridge» – таблиця «Холодильник для крові» має такі атрибути:
1)	blood_fridge_id – ідентифікатор холодильника;
2)	name – назва холодильника;
3)	capacity_ml – місткість холодильника в мілілітрах.

г)	table «blood_group» – таблиця «Групи крові» має такі атрибути:
1)	blood_group_id – ідентифікатор групи крові;
2)	name – назва групи крові;
3)	rhesus_factor – резус-фактор.

д)	table «blood_inventory» – таблиця «Інвентар крові» має такі атрибути:
1)	blood_inventory_id – ідентифікатор інвентарної одиниці;
2)	blood_bank_id – ідентифікатор банку крові, де знаходиться одиниця;
3)	blood_group_id – ідентифікатор групи крові;
4)	blood_part_id – ідентифікатор компоненту крові;
5)	creation_date – дата створення одиниці;
6)	expiry_date – дата закінчення терміну придатності.
е)	table «blood_part» –таблиця «Компоненти крові» має такі атрибути:
1)	blood_part_id – ідентифікатор компоненту крові;
2)	name – назва компоненту;
3)	volume_per_bag_ml – обсяг однієї одиниці компоненту в мілілітрах;
4)	storage_conditions – умови зберігання;
5)	shelf_life_days – термін придатності в днях.

ж)	table «blood_part_request» –таблиця «Запити на компоненти крові» має такі атрибути:
1)	request_blood_id – ідентифікатор запиту крові; crime_type – тип злочину.
2)	blood_part_id – ідентифікатор компоненту крові;
3)	quantity – кількість одиниць.

з)	table «blood_request» – таблиця «Запити крові» має такі атрибути:
1)	request_blood_id – ідентифікатор запиту;
2)	status – статус запиту;
3)	request_date – дата створення запиту;
4)	hospital_id – ідентифікатор лікарні, яка подала запит;
5)	blood_bank_id – ідентифікатор банку крові, що виконує запит.
и)	table «hospital» – таблиця «Лікарня» має такі атрибути:
1)	     request_blood_id – ідентифікатор запиту;
2)	     hospital_id – ідентифікатор лікарні;
3)	     name – назва лікарні;
4)	     location – місце розташування лікарні;
5)	     contact_number – контактний номер лікарні.

к)	table «donor» – таблиця «Донор» має такі атрибути
1)	     donor_id – ідентифікатор донора;
2)	     name – ім'я донора;
3)	     blood_group_id – ідентифікатор групи крові донора;
4)	     email – електронна пошта донора;
5)	      contact_number – контактний номер телефону донора;
6)	     sex – стать донора;
7)	     age – вік донора;
8)	     date_of_birth – дата народження донора.

л)	table «blood_transaction» – таблиця «Транзакції крові» має такі атрибути:
1)	     blood_transaction_id – ідентифікатор транзакції;
2)	     transaction_type – тип транзакції;
3)	     supply_id – ідентифікатор постачання;
4)	     request_blood_id – ідентифікатор запиту на кров;
5)	     blood_part_id – ідентифікатор компонента крові;
6)	     quantity – кількість;
7)	     transaction_date – дата транзакції;
8)	     blood_bank_id – ідентифікатор банку крові.

м)	table «blood_transport» – таблиця «Перевезення крові» має такі атрибути: 
1)	     blood_transport_id – ідентифікатор транспорту;
2)	     bank_id – ідентифікатор банку крові;
3)	     start_time – час початку транспортування;
4)	     end_time – час завершення транспортування;
5)	     user_id – ідентифікатор користувача;
6)	     request_blood_id – ідентифікатор запиту на кров;
7)	     status – статус транспортування.

н)	table «user» – таблиця «Користувачі» має такі атрибути: 
1)	     user_id – ідентифікатор користувача;
2)	     name – ім'я користувача;
3)	     email – електронна пошта;
4)	     password – пароль;
5)	     role_id – ідентифікатор ролі користувача.

о)	table «user_role» – таблиця «Ролі користувачів» має такі атрибути:
1)	     role_id – ідентифікатор ролі;
2)	     name – назва ролі.

п)	table «transport_sensor» – таблиця «Датчики транспортування» має такі атрибути:
1)	     blood_fridge_id – ідентифікатор холодильника для крові;
2)	     blood_transport_id – ідентифікатор транспортування крові;
3)	     temperature – температура в транспорті;
4)	     time_stamp – позначка часу;
5)	     status – статус датчика;
6)	     transport_sensor_id – ідентифікатор датчика транспортування.

р)	table «supply» – таблиця «Постачання» має такі атрибути:
1)	     supply_id – ідентифікатор постачання;
2)	     blood_bank_id – ідентифікатор банку крові;
3)	     blood_donation_center_id – ідентифікатор центру здачі крові;
4)	     supply_date – дата постачання.

с)	table «supply_details» – таблиця «Деталі постачання» має такі атрибути:
1)	     supply_details_id – ідентифікатор деталей постачання;
2)	     supply_id – ідентифікатор постачання;
3)	     blood_group_id – ідентифікатор групи крові;
4)	     creation_date – дата створення;
5)	     expiry_date – дата закінчення терміну придатності.


Рисунок 1.3 –  Схема бази даних «Банк крові»


1.6	Розробка функції роботи з БД 


Розробка функцій роботи з базою даних здійснювалася з використанням ORM, зокрема бібліотеки SQLAlchemy, яка є однією з найпопулярніших у Python. ORM (Object-Relational Mapping) — це підхід, що дозволяє працювати з базою даних через об’єкти мови програмування, замість написання сирих SQL-запитів. У цьому випадку таблиці бази даних представляються у вигляді класів Python, де кожна колонка таблиці відповідає атрибуту класу. SQLAlchemy забезпечує автоматичне перетворення даних між об’єктами та записами бази, що спрощує процес взаємодії з даними.
У SQLAlchemy використовується мапінг, завдяки якому класи Python зв’язуються з таблицями бази даних. Для виконання CRUD-операцій використовується транзакційна модель через спеціальні сесії. Це дозволяє працювати з даними у рамках чітко визначених транзакцій, забезпечуючи цілісність і безпеку інформації.
Наприклад, у таблиці Hospital зберігається інформація про лікарні, включаючи їхню назву, електронну пошту, місцезнаходження та контактний номер. Нижче наведено приклад моделі, яка реалізована за допомогою SQLAlchemy

from sqlalchemy import Column, Integer, String, ForeignKey
from sqlalchemy.orm import relationship, backref
from app import db

class Hospital(db.Model):
    __tablename__ = "hospital"

    hospital_id = Column(Integer, primary_key=True)
    name = Column(String(255), nullable=False)
    email = Column(String(255), nullable=False, unique=True)
    location = Column(String(255), nullable=False)
    contact_number = Column(String(50), nullable=False)
    user_id = Column(Integer, ForeignKey('user.user_id'), nullable=False)

    user = relationship("User", backref=backref("hospitals", lazy=True))

    def __repr__(self):
        return f"<Hospital {self.name}>"

Цей клас відповідає таблиці hospital у базі даних, а зв’язок user_id використовується для прив’язки до іншої таблиці user (зв’язок "багато до одного"). Це забезпечує зручний доступ до об’єктів, пов’язаних із записами в базі даних.
Для виконання CRUD-операцій були створені статичні методи, які ілюструють переваги використання SQLAlchemy. Ось приклад такої функції для створення у системі нової лікарні.

@staticmethod
def create_hospital(data):
    try:
        new_hospital = Hospital(
            name=data.get("name"),
            email=data.get("email"),
            location=data.get("location"),
            contact_number=data.get("contact_number"),
            user_id=data.get("user_id"),
        )
        db.session.add(new_hospital)
        db.session.commit()
        return {"message": "Hospital created successfully"}, 201
    except Exception as e:
        db.session.rollback()
        return ErrorHandler.handle_error(e, message="Failed to create hospital", status_code=500)


1.7	Розробка REST API для взаємодії серверної частини з клієнтами.

Для розробки взаємодії серверної частини з клієнтами було обрано REST, це архітектурний стиль для створення API, який використовує протокол HTTP для обміну даними між клієнтом і сервером. Основною ідеєю REST є забезпечення уніфікованого інтерфейсу для взаємодії з ресурсами, які можна ідентифікувати через унікальні URL-адреси. Ресурси в REST API є різними об'єктами або даними, такими як користувачі, замовлення або доставки, і з ними можна працювати через різні HTTP-методи.
У процесі розробки API було застосовано принципи REST, що включають використання стандартних HTTP-методів: GET для отримання даних, POST для створення нових ресурсів, PUT для оновлення існуючих, і DELETE для видалення ресурсів рис.1.4. 
 
Рисунок  1.4 – Приклад використання стандартних HTTP-методів

Кожен запит API супроводжується відповідним статусом HTTP, що вказує на успішність або помилку операції, наприклад, статуси 200 OK, 404 Not Found, або 500 Internal Server Error рис.1.5 – 1.6. 
 
Рисунок 1.5  – Приклад отримання статусу 200 
 
Рисунок  1.6 – Приклад отримання статусу 404

Розроблений API організовано навколо ресурсів, для яких визначено унікальні ендпоінти для виконання CRUD-операцій. Наприклад, ендпоінт GET /blood-groups дозволяє отримати список груп крові рис.1.7, а POST /create-hospital— дозволяє зареєструвати нову лікарню у системі рис.1.8. 

Рисунок  1.7 – Приклад GET запиту

Рисунок  1.8 – Приклад POST запиту

Також було забезпечено відловлювання та обробку помилок, які можуть бути отримані під час введення користувачами некоректних даних, наприклад спроба отримати дані неіснуючої лікарні буде супроводжуватися статусом 404 і відповідним повідомленням рис.1.9.
 
Рисунок  1.9 – Приклад обробки помилки

Для захисту інформації реалізовано механізми аутентифікації та авторизації, що включають використання токенів для перевірки прав доступу. 
Для захисту інформації в API була реалізована система аутентифікації та авторизації, яка використовує JWT (JSON Web Tokens). JWT є стандартом для передачі інформації між двома сторонами в компактному та захищеному вигляді. Це дозволяє забезпечити безпеку, оскільки всі дані в токені підписуються за допомогою секретного ключа, що дозволяє перевіряти цілісність даних і їх автентичність.
Для розробки була використана бібліотека, така як Flask-JWT-Extended, яка полегшує інтеграцію цієї технології в додаток. Бібліотека дозволяє створювати та перевіряти JWT токени для аутентифікації користувачів, а також для авторизації доступу до захищених ендпоінтів API.
Процес аутентифікації з використанням JWT в даному випадку складається з кількох етапів. Спочатку, коли користувач намагається увійти в систему, він надсилає свої облікові дані (наприклад, ім’я користувача та пароль) через HTTP-запит до ендпоінта аутентифікації. Якщо дані правильні, сервер генерує JWT токен, що містить необхідну інформацію про користувача  та певні права доступу, і відправляє цей токен назад користувачеві рис.1.10.
 
Рисунок 1.10 – Приклад входу у систему і видачі токена доступу

Згодом, кожен наступний запит до захищеного ресурсу клієнт повинен надсилати цей токен у заголовку HTTP-запиту, в заголовку Authorization у форматі Bearer рис.1.11. Сервер на основі токена перевіряє його достовірність. 
За допомогою Flask-JWT-Extended також налаштовано термін дії токена, що буде вимагати у користувача знову залогінитися через деякий час.

Рисунок 1.11 – Приклад передачі токена та успішного доступу до захищеного ресурсу
1.8	Специфікація розробленого API

Маршрути, створені для роботи з банками крові рис. 1.12–1.15:
	маршрут /banks не приймає вхідних параметрів, повертає перелік усіх банків, зареєстрованих у системі, та інформацію про кожен з них.
	маршрут /bank/<int:blood_bank_id> приймає blood_bank_id (ідентифікатор банку) як вхідний параметр, повертає детальну інформацію про конкретний банк крові.
	маршрут /create-bank приймає вхідні параметри для створення нового банку крові, такі як назва банку, електронна адреса, локація, контактний телефон, ідентифікатор власника. Повертає повідомлення про успішне створення банку крові.
	маршрут /update-bank/<int:blood_bank_id> приймає blood_bank_id (ідентифікатор банку) та оновлену інформацію про банк крові для редагування. Повертає повідомлення про успішне оновлення даних банку крові.

Рисунок 1.12 – Приклад вхідних і вихідних параметрів маршруту /banks
 
Рисунок 1.13 – Приклад вхідних і вихідних параметрів маршруту /bank/<int:blood_bank_id>

Рисунок 1.14 – Приклад вхідних і вихідних параметрів маршруту /create-bank

Рисунок 1.15 – Приклад вхідних і вихідних параметрів маршруту /update-bank/<int:blood_bank_id>

Маршрути, створені для роботи з лікарнями рис.1.16-1.19:
	маршрут /hospitals: не приймає вхідних параметрів, повертає перелік усіх лікарень, зареєстрованих у системі, та інформацію про кожну з них.
	маршрут /hospital/<int:hospital_id>: приймає hospital_id (ідентифікатор лікарні) як вхідний параметр, повертає детальну інформацію про конкретну лікарню.
	маршрут /create-hospital: приймає вхідні параметри для створення нової лікарні, такі як назва лікарні, електронна адреса, локація, контактний телефон, ідентифікатор відповідальної особи. Повертає повідомлення про успішне створення лікарні.
	маршрут /update-hospital/<int:hospital_id>: приймає hospital_id (ідентифікатор лікарні) та оновлену інформацію про лікарню для редагування. Повертає повідомлення про успішне оновлення даних лікарні.

Рисунок 1.16 – Приклад вхідних і вихідних параметрів маршруту /hospitals
 
Рисунок 1.17 – Приклад вхідних і вихідних параметрів маршруту /hospital/<int:hospital_id>
 
Рисунок 1.18 – Приклад вхідних і вихідних параметрів маршруту /create-hospital
 
Рисунок 1.19 – Приклад вхідних і вихідних параметрів маршруту /update-hospital/<int:hospital_id>

Маршрути, створені для роботи переліком груп крові рис. 1.20–1.21:
	маршрут / blood-groups не приймає вхідних параметрів, повертає перелік усіх існуючих груп крові та резусів;
	маршрут /blood-group/<int:blood_group_id> приймає blood_group_id (ідентифікатор групи крові) як вхідний параметр, повертає детальну інформацію про групу крові. 

Рисунок 1.20 – Приклад вхідних і вихідних параметрів маршруту /blood-groups

Рисунок 1.21 – Приклад вхідних і вихідних параметрів маршруту /blood-group/<int:blood_group_id>

Маршрути, створені для роботи переліком частин крові 1.22–1.23:
	маршрут /blood-parts не приймає вхідних параметрів, повертає перелік усіх існуючих груп крові та резусів;
	маршрут /blood-part/<int:blood_part_id> приймає blood_part_id (ідентифікатор частини крові) як вхідний параметр, повертає детальну інформацію про частину крові.
 
Рисунок 1.22 – Приклад вхідних і вихідних параметрів маршруту /blood-parts

Рисунок 1.23 – Приклад вхідних і вихідних параметрів маршруту /blood-part/<int:blood_part_id>

Маршрути, створені для роботи з донорами 1.24–1.29:
	маршрут /donors  не приймає вхідних параметрів, повертає перелік усіх донорів, зареєстрованих у системі, та інформацію про кожного з них.
	маршрут /donor/<int:user_id> приймає user_id (ідентифікатор користувача) як вхідний параметр, повертає детальну інформацію про конкретного користувача.
	маршрут /create-donor приймає вхідні параметри для занесення у систему інформації для нового донора, такі як група крові, стать, рік народження. Повертає повідомлення про успішне створення запису.
	маршрут /update-donor/<int:donor_id> приймає donor_id (ідентифікатор донора) та оновлену інформацію про донора для редагування. Повертає повідомлення про успішне оновлення даних донора.
	маршрут /create-donation-session приймає вхідні параметри для занесення у систему інформації про нову здачу крові конкретного донора. Повертає повідомлення про успішне створення запису.
	маршрут /donation-session/<int:donor_id> приймає donor_id (ідентифікатор донора) та видає список усіх його донорський сесій.


 
Рисунок 1.24 – Приклад вхідних і вихідних параметрів маршруту /donors  

Рисунок 1.25 – Приклад вхідних і вихідних параметрів маршруту /donor/<int:user_id>

Рисунок 1.26 – Приклад вхідних і вихідних параметрів маршруту /create-donor
 
Рисунок 1.27 – Приклад вхідних і вихідних параметрів маршруту /update-donor/<int:donor_id>

Рисунок 1.28 – Приклад вхідних і вихідних параметрів маршруту /create-donation-session

Рисунок 1.29 – Приклад вхідних і вихідних параметрів маршруту /donation-session/<int:donor_id>

Маршрути, створені для роботи з поставками 1.30–1.37:
	маршрут /supplies/<int:blood_bank_id>  приймає ідентифікатор банку, повертає перелік усіх постачань, зареєстрованих у системі для заданого банку, та інформацію про кожне з них.
	маршрут /supply/<int:supply_id> приймає supply_id (ідентифікатор постачання) як вхідний параметр, повертає детальну інформацію про конкретне постачання.
	маршрут /create-supply приймає дані про нове постачання, зокрема ідентифікатори відповідних об'єктів та дату постачання. Повертає повідомлення про успішне створення постачання.
	маршрут /update-supply/<int:supply_id> приймає supply_id (ідентифікатор постачання) та оновлену інформацію. повертає повідомлення про успішне оновлення даних постачання.
	маршрут /supply-details/<int:supply_id>  приймає ідентифікатор поставки, повертає перелік усіх деталей постачання та інформацію про кожну з них для заданої поставки.
	маршрут /supply-detail/<int:supply_details_id> приймає supply_details_id (ідентифікатор деталей постачання) як вхідний параметр, повертає детальну інформацію про конкретну деталь постачання.
	маршрут /create-supply-detail приймає дані для створення нової деталі постачання, зокрема інформацію про групу крові, дату створення та термін придатності. повертає повідомлення про успішне створення деталі. 
	маршрут /update-supply-detail/<int:supply_details_id> приймає supply_details_id (ідентифікатор деталей постачання) та оновлену інформацію. повертає повідомлення про успішне оновлення деталей постачання.

 
Рисунок 1.30 – Приклад вхідних і вихідних параметрів маршруту /supplies/<int:blood_bank_id>

Рисунок 1.31 – Приклад вхідних і вихідних параметрів маршруту 
/create-supply 
 
Рисунок 1.32 – Приклад вхідних і вихідних параметрів маршруту /supplies/<int:blood_bank_id>

Рисунок 1.33 – Приклад вхідних і вихідних параметрів маршруту /update-supply/<int:supply_id

Рисунок 1.34 – Приклад вхідних і вихідних параметрів маршруту /create-supply-detail
 
Рисунок 1.35 – Приклад вхідних і вихідних параметрів маршруту /supply-detail/<int:supply_details_id>

Рисунок 1.36 – Приклад вхідних і вихідних параметрів маршруту /supply-details/<int:supply_id>

Рисунок 1.37 – Приклад вхідних і вихідних параметрів маршруту /update-supply-detail/<int:supply_details_id>


Маршрути, створені для роботи з заявками на постачання рис. 1.38–1.43:

	маршрут /blood-requests/<int:blood_bank_id>, приймає ідентифікатор банку і  повертає перелік усіх запитів на кров, зареєстрованих у системі які прийняв даний банк, разом з відповідною інформацією про кожен запит.
	маршрут /blood-request/<int:request_blood_id> приймає request_blood_id (ідентифікатор запиту на кров) як вхідний параметр, повертає детальну інформацію про конкретний запит.
	маршрут /create-blood-request приймає дані для створення нового запиту на кров, включаючи інформацію про тип крові, необхідну кількість та інші пов'язані дані. повертає повідомлення про успішне створення запиту.
	маршрут /update-blood-request/<int:request_blood_id> приймає request_blood_id (ідентифікатор запиту на кров) та оновлену інформацію про запит. повертає повідомлення про успішне оновлення запиту.
	маршрут /blood-part-requests/<int:request_blood_id> приймає request_blood_id як вхідний параметр, повертає список усіх запитів на окремі компоненти крові, що стосуються конкретного запиту.
	маршрут /blood-part-request/<int:request_blood_id>/<int:blood_part_id> приймає request_blood_id (ідентифікатор запиту на кров) та blood_part_id (ідентифікатор компонента крові) як вхідні параметри, повертає інформацію про конкретний запит на компонент крові в межах запиту.
	маршрут /create-blood-part-request приймає дані для створення запиту на окремий компонент крові, включаючи інформацію про компонент, його кількість та інші пов'язані дані. повертає повідомлення про успішне створення запиту.

 
Рисунок 1.38 – Приклад вхідних і вихідних параметрів маршруту /create-blood-request

Рисунок 1.39 – Приклад вхідних і вихідних параметрів маршруту /blood-requests/<int:blood_bank_id>
 
Рисунок 1.40 – Приклад вхідних і вихідних параметрів маршруту /blood-request/<int:request_blood_id>

Рисунок 1.41 – Приклад вхідних і вихідних параметрів маршруту /create-blood-part-request
 
Рисунок 1.42 – Приклад вхідних і вихідних параметрів маршруту /blood-part-request/<int:request_blood_id>/<int:blood_part_id>

Рисунок 1.43 – Приклад вхідних і вихідних параметрів маршруту /blood-part-requests/<int:request_blood_id>

Маршрути, створені для роботи з транспортуванням крові рис. 1.44–1.47:

	маршрут /blood-transports/<int:blood_bank_id> приймає blood_bank_id (ідентифікатор банку крові) як вхідний параметр, повертає список усіх транспортувань крові, пов'язаних із зазначеним банком крові. інформація містить деталі про кожне транспортування, включаючи дати та обсяги перевезеної крові.
	маршрут /blood-transport/<int:blood_transport_id> приймає blood_transport_id (ідентифікатор транспортування) як вхідний параметр, повертає детальну інформацію про конкретне транспортування крові.
	маршрут /create-blood-transport приймає дані для створення нового запису про транспортування крові, включаючи інформацію про банк крові, пункт відправлення, пункт призначення, кількість крові та дату транспортування. повертає повідомлення про успішне створення запису.
	маршрут /update-blood-transport/<int:blood_transport_id> приймає blood_transport_id (ідентифікатор транспортування) та оновлені дані про транспортування, такі як місце призначення, дата чи обсяг крові. повертає повідомлення про успішне оновлення запису.

Рисунок 1.44 – Приклад вхідних і вихідних параметрів маршруту /blood-transports/<int:blood_bank_id>

Рисунок 1.45 – Приклад вхідних і вихідних параметрів маршруту /blood-transport/<int:blood_transport_id>
 
Рисунок 1.46 – Приклад вхідних і вихідних параметрів маршруту /create-blood-transport

Рисунок 1.47 – Приклад вхідних і вихідних параметрів маршруту /update-blood-transport/<int:blood_transport_id>

Маршрути створені для управління холодильниками для зберігання крові рис. 1.48–1.50:
	маршрут /blood-fridges не приймає вхідних параметрів, повертає список усіх холодильників, зареєстрованих у системі. 
	маршрут /blood-fridge/<int:blood_fridge_id> приймає blood_fridge_id (ідентифікатор холодильника) як вхідний параметр, повертає детальну інформацію про конкретний холодильник для крові. ця інформація може включати обсяг, температуру, розташування та інші характеристики.
	маршрут /create-blood-fridge приймає дані для створення нового холодильника, такі як місцезнаходження, максимальна місткість та початковий стан. повертає повідомлення про успішне створення запису.

Рисунок 1.48 – Приклад вхідних і вихідних параметрів маршруту /blood-fridges

 
Рисунок 1.49 – Приклад вхідних і вихідних параметрів маршруту /blood-fridge/<int:blood_fridge_id>

Рисунок 1.50 – Приклад вхідних і вихідних параметрів маршруту /create-blood-fridge



Маршрути створені для управління сенсорами в холодильниках рис. 1.51–1.52:
	маршрут /transport-sensor/<int:blood_transport_id> /<int:blood_fridge_id> приймає два вхідні параметри — blood_transport_id (ідентифікатор транспортного засобу) та blood_fridge_id (ідентифікатор холодильника). повертає список усіх сенсорів, пов'язаних із вказаним транспортним засобом або холодильником. інформація може включати показники сенсорів, такі як температура, вологість або стан.
	маршрут /create-transport-sensor приймає дані для створення нового сенсора, такі як тип сенсора, його характеристики та прив'язка до конкретного транспортного засобу чи холодильника. повертає повідомлення про успішне створення сенсора.


Рисунок 1.51 – Приклад вхідних і вихідних параметрів маршруту /transport-sensor/<int:blood_transport_id>/<int:blood_fridge_id>

Рисунок 1.52 – Приклад вхідних і вихідних параметрів маршруту /create-transport-sensor


Маршрути створені для управління запасами крові та процесами постачання і заявок рис. 1.53-1.59:
	маршрут /process-supply/<int:supply_id> приймає ідентифікатор поставки (supply_id) як вхідний параметр. цей маршрут виконується після того, як працівник банку завершив облік поставки та вніс усі пакети крові у систему. після виклику маршруту кров автоматично розподіляється на складові (лейкоцити, тромбоцити та плазму), які додаються до системи. також у таблиці транзакцій з'являється запис про прибуття певної кількості крові до банку.
	маршрут /blood-inventory/<int:blood_bank_id> приймає ідентифікатор банку крові (blood_bank_id) як вхідний параметр. повертає інформацію про запаси крові у вказаному банку, включаючи кількість і типи компонентів крові.
	маршрут /process-request/<int:blood_bank_id>/<int:request_blood_id> приймає два вхідні параметри — ідентифікатор банку крові (blood_bank_id) та ідентифікатор заявки на кров (request_blood_id), цей маршрут символізує прийняття банком заявки на постачання крові до лікарні, після його виклику статус заявки змінюється на inprogress, і в таблиці транзакцій автоматично створюється запис про кількість запасів крові, які будуть доставлені до лікарні, також автоматично зменшується кількість запасів крові у відповідному банку.
	маршрут /transactions/<int:blood_bank_id>/<start_date>/<end_date> приймає ідентифікатор банку крові (blood_bank_id) та часовий інтервал (start_date і end_date) як вхідні параметри, повертає список транзакцій, здійснених у вказаному банку крові за вибраний період, включаючи типи та кількість крові, що надійшли чи були використані.
	маршрут /find-bank/<int:request_blood_id> приймає ідентифіктор запиту на доставку крові як вхідний параметр, повертає список банків, які повністю або частково покривають вимоги доставки.
	маршрут /daily-report/<int:blood_bank_id> приймає ідентифікатор банку крові (blood_bank_id), повертає звіт по кількості частин крові певної групи та перелік пакеті з частинами крові у яких закінчується термін придатності.
	маршрут /delete-inventory/<int:blood_inventory_id> приймає ідентифікатор запису у таблиці інвентару, повертає повідомлення про успішне його видалення.


Рисунок 1.53 – Приклад вхідних і вихідних параметрів маршруту /process-request/<int:blood_bank_id>/<int:request_blood_id>

Рисунок 1.54 – Приклад вхідних і вихідних параметрів маршруту /blood-inventory/<int:blood_bank_id>

Рисунок 1.55 – Приклад вхідних і вихідних параметрів маршруту /process-supply/<int:supply_id>

Рисунок 1.56 – Приклад вхідних і вихідних параметрів маршруту /transactions/<int:blood_bank_id>/<start_date>/<end_date>

Рисунок 1.57 – Приклад вхідних і вихідних параметрів маршруту /find-bank/<int:request_blood_id> 

Рисунок 1.58 – Приклад вхідних і вихідних параметрів маршруту / daily-report/<int:blood_bank_id> 

Рисунок 1.59 – Приклад вхідних і вихідних параметрів маршруту  


Посилання на файл з кодом в GitHub репозиторії:
https://github.com/NureRubanenkoMariia/arkpz-pzpi-22-7-rubanenko-mariia

Посилання на YouTube відео з презентацією:
https://youtu.be/_zc-g-jnvMA
