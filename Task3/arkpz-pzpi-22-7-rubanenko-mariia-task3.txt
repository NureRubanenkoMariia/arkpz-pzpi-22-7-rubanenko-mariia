Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Кафедра програмної інженерії



Звіт
з лабораторної роботи №3
з дисципліни «Аналіз та рефакторинг коду»
з теми: «Розробка бізнес-логіки та функцій адміністрування серверної частини програмної системи»





Виконав 								Перевірив
ст. гр. ПЗПІ-22-7 							доц. Сокорчук І. П.
Рубаненко М. С.








2024 рік
РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ 
1.1	Мета роботи


Робота спрямована на створення функціональних механізмів, які забезпечують автоматизацію процесів обробки заявок, управління даними та взаємодії з користувачами, а також підтримують цілісність і прозорість роботи системи. У процесі роботи передбачено програмну реалізацію розроблених рішень, створення текстового опису інженерних підходів та візуалізацію ключових процесів у вигляді UML-діаграм.


1.2	Розробка бізнес логіку серверної частини програмної системи



Для розробки бізнес-логіки серверної частини програмної системи була 
використана UML-діаграма діяльності системи «Банк крові». UML-діаграма діяльності є графічним поданням процесів і взаємодій, що відображають алгоритми виконання задач у системі. Вона наочно демонструє послідовність операцій, залежності між етапами, а також умови переходу між ними. Використання такої діаграми значно полегшує планування та реалізацію бізнес-логіки, дозволяє структуровано описати взаємодію користувачів із системою відповідно до їхніх ролей, а також врахувати всі можливі сценарії роботи. Завдяки цьому забезпечується точність і логічна цілісність функціоналу, що реалізується на серверній частині.


Рисунок 1.1 – UML -діаграма діяльності системи «Банк крові»

Процес починається з початкової точки, позначеної чорним кругом, що символізує старт виконання операцій для користувача або системи. Користувач переходить до входу в систему, де перевіряється умова: чи є він новим користувачем. Якщо користувач новий, він переходить до процесу реєстрації, а якщо ні, отримує доступ до основного функціоналу, відповідного до своєї ролі.
На етапі реєстрації користувач обирає свою роль у системі. Доступні три ролі: власник банку крові, який реєструє власну установу; працівник лікарні, який подає заявки на кров; або донор, фізична особа, що готова здавати кров. Для кожної ролі передбачено заповнення відповідної форми. Власник банку крові реєструється як установа, працівник лікарні — як представник медичної установи, а донор — за стандартною реєстраційною процедурою. Після успішної реєстрації обліковий запис створюється, і користувач може переходити до виконання завдань.
Після входу в систему або завершення реєстрації користувач взаємодіє із системою залежно від своєї ролі.
Донор має змогу редагувати особистий профіль, змінюючи персональні дані, переглядати рекомендації щодо здоров’я, включно з підготовкою до здачі крові та післяпроцедурним доглядом, а також отримувати доступ до історії донорства, де відображаються всі попередні запити та внески.
Працівник лікарні може подавати заявки на кров, заповнюючи відповідну форму. Система перевіряє банки крові, які відповідають умовам заявки. Якщо знайдено банки, що задовольняють потреби, працівник лікарні надсилає запит до обраного банку. У випадку, якщо лише один банк може задовольнити запит, система надає інформацію про нього, зокрема його можливості покриття заявки.
Функціонал працівників банку поділяється на два рівні: власник банку та працівники банку.
Власник банку реєструє нових співробітників, надаючи їм відповідні ролі, та переглядає статистику щодо постачань крові та доставок до лікарень.
Працівники банку приймають заявки від лікарень. Після перевірки наявності потрібного обсягу крові приймається рішення щодо заявки. Працівники також вносять дані про постачання у систему, контролюють кількість крові у банку та строки її придатності, оформлюють документи для доставки крові до лікарень та призначають транспортувальників.
Транспортувальник приймає заявку на доставку крові до лікарні, налаштовує датчики холодильників для контролю температури та інших параметрів, важливих для належного зберігання крові, і здійснює доставку.
Після виконання всіх завдань користувач завершує свою діяльність у системі, що відображається чорним кругом із обвідкою, який символізує логічне завершення процесу.


1.3	Розробка функції адміністрування серверної частини програмної системи


Для розробки функцій адміністрування серверної частини використовують UML-діаграма взаємодії (Interaction Diagram), це графічне зображення, яке використовується для моделювання процесів взаємодії між об'єктами у системі. Вона демонструє, як об'єкти передають повідомлення один одному, зображаючи порядок виклику методів, передачу даних і результатів. Одним із найпоширеніших видів діаграм взаємодії є Sequence Diagram, яка фокусується на хронологічній послідовності повідомлень, допомагаючи зрозуміти логіку роботи системи та поведінку її компонентів у часі.
Для проєкту було обрано Sequence Diagram, оскільки вона надає змогу чітко і лаконічно представити взаємодію користувачів із системою, що особливо важливо в умовах складної архітектури. Вона дозволяє зобразити порядок виконання операцій та взаємодію між різними модулями системи. Завдяки цьому діаграма допомагає розробникам та зацікавленим сторонам глибше зрозуміти функціонал системи, зокрема способи обробки запитів, передачі даних і виклику методів.
Оскільки система має багато видів користувачів (донори, працівники лікарень, власники банків крові, працівники банків крові, транспортувальники), діаграму було розділено на п'ять окремих частин. Це було зроблено для того, щоб спростити структуру діаграм, уникнути надмірного перевантаження інформацією та забезпечити більш детальний опис функціоналу кожної ролі.

Рисунок 1.2 – Sequence Diagram для ролі власник банку

Діаграма відображає взаємодію між власником банку крові та компонентами системи у вигляді Sequence Diagram. Власник банку крові ініціює роботу через API, використовуючи три основні маршрути: /login, /register-user і /transactions. Перший маршрут дозволяє власнику банку крові здійснити вхід до системи. Для цього API передає запит до методу authenticate() у модулі user_model, який перевіряє автентифікацію користувача. У разі успішної перевірки система повертає статус виконання запиту та токен доступу, який дозволяє подальшу взаємодію із системою.
Другий маршрут, /register-user, використовується для реєстрації нового користувача. Власник банку крові надсилає запит через API, який викликає метод create_user() у user_model. Після виконання операції створення нового користувача система повертає статус, що вказує на успішність чи невдачу реєстрації.
Третій маршрут, /transactions, дає можливість отримати інформацію про транзакції банку крові за певними параметрами. API передає запит до методу get_transactions_by_bank_and_date(), що належить до модуля transaction_model. У відповідь система повертає дані про відповідні транзакції.

Рисунок 1.3 – Sequence Diagram для ролі транспортувальник

Транспортувальник взаємодіє із системою через кілька маршрутів API: /login, /update-blood-transport, а також /transport-sensor/<int:blood_transport_id>/<int:blood_fridge_id>.
Маршрут /login використовується для входу до системи. Запит від транспортувальника надходить до API, яке викликає метод authenticate() у модулі user_model. У разі успішної автентифікації система повертає статус виконання та токен доступу, який дозволяє здійснювати подальші запити.
Маршрут /update-blood-transport дозволяє оновлювати інформацію про транспортування крові. Запит передається через API до методу update_transport() у модулі transport_model, який обробляє оновлення даних. Після цього система повертає відповідний статус операції.
Маршрут /transport-sensor/<int:blood_transport_id>/<int:blood_fridge_id> використовується для отримання даних із сенсорів холодильника, пов’язаних із транспортуванням крові. API надсилає запит до методу get_all_sensors() у модулі transport_sensor_model, який збирає необхідну інформацію. Під час виконання цього запиту система також звертається до методу get_fridge_name() у fridge_model для отримання даних про холодильник. Отримана інформація передається назад транспортувальнику.

Рисунок 1.4 – Sequence Diagram для ролі працівник банку

Працівник банку починає роботу із системою через маршрут /login, який відповідає за автентифікацію. Запит надходить до API, яке викликає метод authenticate() у модулі user_model. У разі успішної автентифікації система повертає статус операції та токен доступу.
Після входу працівник може виконувати різні операції, маршрут /create-blood-transport обробляє запит, що передається через API до методу create_transport() у модулі transport_model. Система створює новий запис про транспортування крові та повертає статус виконання. Маршрут /create-supply надсилає запит до методу create_supply() у модулі supply_model. Цей метод створює нове постачання, після чого повертається статус виконання. Запит через маршрут /create-supply-detail передається до методу create_details() у модулі supply_details_model, який зберігає деталі постачання, тобто перелік поставки, та повертає статус операції.
Для обробки запитів від лікарень використовується маршрут /process-request, який викликає метод process-request() у модулі request_model. Цей метод обробляє запит, а також може викликати create_transaction для реєстрації транзакції у системі, а також метод delete_blood_part для видалення з переліку запасів банку частини крові, які будуть надіслані лікарні.  Після завершення система повертає відповідний статус.
Нарешті, працівник банку може отримати щоденний звіт через маршрут /daily-report/<int:blood_bank_id>. Запит викликає метод generate_daily_report() у модулі inventory_model, який створює звіт на основі даних запасів банку крові та повертає результати.

 
Рисунок 1.5 – Sequence Diagram для ролі працівник лікарні


Процес взаємодії працівника лікарні із системою починається зі звернення до маршруту авторизації /login. На цьому етапі API здійснює перевірку облікових даних користувача за допомогою методу authenticate(), реалізованого у модулі user_model. У разі успішної перевірки система повертає статус виконання операції та токен, який дозволяє працівнику лікарні перейти до основних функцій.
Далі працівник має можливість створити запит на кров через маршрут /create-blood-request. Цей запит передається до методу create_request() у модулі request_model, де система формує відповідний запис про потребу в крові та повертає статус виконання. Потім працівник лікарні створює перелік потрібних частин крові з їх кількістю, використовується маршрут /create-blood-part-request. У цьому випадку API звертається до методу create_part_request() у модулі request_part_model, який обробляє запит та забезпечує збереження необхідних даних. Після працівник відправляє у обробку свій запит, система викликає метод find_best_matching_bank(), що дозволяє ідентифікувати банк крові, який найкраще відповідає умовам заявки, та передає відповідну інформацію про банки крові працівнику лікарні.
Обраному банку працівник надсилає запит, використовується маршрут /send-requeеt/<int:request_blood_id>. API взаємодіє з модулем request_model, викликаючи метод update_request(), що забезпечує оновлення даних у відповідному запиті та надсилає працівнику лікарні підтвердження про успішне виконання операції. У процесі обробки запитів, коли потрібна деталізація інформації про запит на конкретну частину крові, API звертається до модуля inventory_model, викликаючи метод get_part_request_id(), який надає актуальні дані з інвентарю.













Рисунок 1.6 – Sequence Diagram для ролі донор

Процес взаємодії донора із системою починається зі звернення до маршруту авторизації /login. На цьому етапі API маршрути передають запит до методу authenticate(), що реалізований у модулі user_model. У разі успішної перевірки облікових даних система повертає статус виконання операції та токен, який дозволяє донору отримати доступ до подальших функцій системи.
Після авторизації донор має можливість створити свій профіль, скориставшись маршрутом /create-donor-profile. У цьому випадку API маршрути передають запит до методу create_donor(), що реалізований у модулі donor_model. Система обробляє запит на створення профілю донора та повертає статус виконання операції.
Для оновлення профілю донор звертається до маршруту /update-donor-profile. API маршрути викликають метод update_donor() у модулі donor_model, який обробляє запит на оновлення даних профілю донора. Після завершення операції система надсилає статус виконання оновлення.




1.4	Розробка програмної реалізацію бізнес логіки та функцій адміністрування серверної частини


Для реалізації серверної частини використовується архітектура REST API, яка дозволяє взаємодіяти з клієнтськими додатками через стандартизовані HTTP-запити. Основна логіка зосереджена на обробці запитів, перевірці даних, виконанні операцій із базою даних та поверненні відповідей у форматі JSON. Бізнес-логіка реалізована у вигляді набору модулів, кожен з яких відповідає за певний функціонал системи. 
Обробка заявок на кров додаток А, серверна частина перевіряє доступність необхідної крові у банках, сортує банки за відповідністю умовам запиту, та автоматично обирає найкращий варіант.
	Функція find_best_matching_bank реалізує бізнес-логіку для автоматичної обробки заявок лікарень на кров. Вона вирішує завдання визначення банку крові, який найкраще покриває потреби заявки, аналізуючи запаси крові у всіх доступних банках і обираючи оптимальний варіант. Якщо запасів у жодному банку не вистачає, система пропонує банк, що максимально покриває об’єм заявки, оновлюючи в заявку.
Функція починає з отримання списку заявок на кров для конкретного запиту, ідентифікованого через request_blood_id. Для кожної позиції заявки формується карта необхідних компонентів крові у форматі blood_part_id_blood_group_id, де ключем є тип і група крові, а значенням — кількість, потрібна лікарні. Далі система аналізує запаси кожного банку крові. Запаси завантажуються через модель BloodInventory, і для кожного банку формується карта доступних компонентів крові з урахуванням їх кількості. Ці дані дозволяють оцінити відповідність кожного банку вимогам заявки.
Визначення покриття здійснюється шляхом порівняння необхідної кількості кожного компонента із запасами у банку. Якщо банк має достатню кількість певного компонента, ця кількість зараховується до покриття matched_quantities. Якщо компоненту не вистачає, система реєструє його нестачу missing_quantities і враховує лише доступну кількість у покритті. Загальне покриття банку обчислюється як сума всіх зарахованих одиниць, що відповідають заявці.
Після цього система порівнює всі банки за загальним покриттям і обирає банк із максимальною кількістю задоволених одиниць. Якщо обраний банк повністю покриває всі потреби заявки, результат повертається без подальших змін. У випадку, якщо деяких компонентів не вистачає, система зменшує кількість у заявці на недоотримані обсяги і фіксує ці зміни в базі даних.
Реалізація також передбачає обробку помилок. У разі виникнення виключення всі незавершені транзакції скасовуються, щоб уникнути некоректного стану даних, а користувач отримує відповідне повідомлення.
Таким чином, функція забезпечує автоматизацію процесу обробки заявок, ефективно використовуючи доступні ресурси банків крові, і дозволяє лікарням отримати найбільш відповідні варіанти поставки.
Обробка поставок крові додаток Б, серверна частина приймає поставку та вносить її перероблений вигляд у базу. 
Функція process_supply_to_inventory реалізує логіку обробки поставок цільної крові в банк. Її головною метою є автоматичний розрахунок компонентів крові (еритроцити, плазма, тромбоцити), які виділяються з кожної одиниці крові, та їх додавання до загального обліку банку крові. Крім цього, для кожного компонента система фіксує термін придатності, залежно від дати його створення та нормативного строку зберігання.
Функція починає роботу з отримання даних про поставку через її унікальний ідентифікатор supply_id. Далі отримуються деталі поставки (наприклад, група крові, дата постачання) і список усіх типів компонентів крові, які можуть бути виділені з цільної крові.
Для кожного запису в деталях поставки система обробляє компоненти. У циклі для кожного типу компонентів розраховується дата закінчення терміну придатності: до дати постачання додається кількість днів, допустимих для зберігання цього компонента. Потім створюється новий запис у таблиці BloodInventory, який включає ідентифікатор банку крові, тип компонента, групу крові, дату створення та термін придатності. Цей запис додається до бази даних.
Після завершення процесу додавання компонентів система також створює запис у таблиці транзакцій BloodTransaction. У записі вказується тип транзакції ("incoming"), кількість кожного компонента, його тип, ідентифікатор поставки та банк крові. Це дозволяє підтримувати прозорий облік усіх надходжень і змін у запасах крові.
Реалізація враховує можливість виникнення помилок у процесі роботи. Якщо під час виконання функції трапляється виключення, усі незавершені транзакції скасовуються за допомогою db.session.rollback(), що гарантує цілісність даних. Таким чином, функція забезпечує автоматизацію процесу обробки поставок і підтримує точний облік усіх змін у запасах банку крові.
Обробка заявок на кров банком додаток В, серверна частина приймає заявку на постачання крові до лікарні певним банком та вносить відповідні змани у кількість запасів банку. 
Функція process_request реалізує обробку банком крові заявки, яка надходить від лікарні. Основні завдання цієї функції — виконання доставки необхідної крові та компонентів, автоматичне оновлення даних у таблицях обліку запасів і транзакцій, а також контроль наявності достатньої кількості необхідних компонентів у банку крові. Функція отримує заявку через її ідентифікатор request_blood_id. Якщо така заявка відсутня, система повертає повідомлення про помилку. Якщо заявка знайдена, їй встановлюється статус inprogress, і вона прив'язується до конкретного банку крові blood_bank_id. 
Для кожного запиту компонентів крові (наприклад, еритроцити або плазма) визначається потрібна кількість quantity_to_remove і тип компонента blood_part_id. Далі функція шукає записи про доступні компоненти у таблиці BloodInventory, що відповідають конкретному банку крові. Записи сортуються за датою створення, щоб забезпечити використання найстаріших компонентів (стратегія FIFO — "першим прийшло, першим пішло").
Кожен запис про компонент видаляється з бази даних доти, доки не буде виконано потрібну кількість. Якщо під час видалення виявиться, що необхідної кількості компонентів немає, транзакція скасовується (db.session.rollback()), а функція повертає повідомлення про нестачу крові з зазначенням бракуючої кількості.
Для кожного видаленого компонента створюється запис у таблиці BloodTransaction із вказанням типу транзакції (outgoing), ідентифікатора заявки, типу компоненту, кількості, що була видалена, та банку крові.
Після успішного видалення всіх необхідних компонентів функція зберігає зміни в базі даних і повертає повідомлення про успішну обробку заявки. 
Функція автоматично оновлює стан запасів банку крові і створює записи про кожну транзакцію. Це дозволяє забезпечити прозорий облік змін у системі та мінімізує ризики помилок через людський фактор.


Посилання на файл з кодом в GitHub репозиторії:
https://github.com/NureRubanenkoMariia/arkpz-pzpi-22-7-rubanenko-mariia

Посилання на YouTube відео:
https://youtu.be/hsZk1pzIxSc







Додаток А


@staticmethod
def find_best_matching_bank(request_blood_id):
    try:
        blood_part_requests = BloodPartRequest.query.filter_by(request_blood_id=request_blood_id).all()

        required_quantities = {
            f"{req.blood_part_id}_{req.blood_group_id}": req.quantity
            for req in blood_part_requests
        }

        bank_coverage = {}
        blood_banks = BloodBank.query.all()
        for bank in blood_banks:
            bank_id = bank.blood_bank_id
            inventory = BloodInventory.query.filter_by(blood_bank_id=bank_id).all()
            available_quantities = {}

            for inv in inventory:
                key = f"{inv.blood_part_id}_{inv.blood_group_id}"
                available_quantities[key] = available_quantities.get(key, 0) + 1

            matched_quantities = {}
            missing_quantities = {}
            for key, req_qty in required_quantities.items():
                available_qty = available_quantities.get(key, 0)
                if available_qty >= req_qty:
                    matched_quantities[key] = req_qty
                else:
                    matched_quantities[key] = available_qty
                    missing_quantities[key] = req_qty - available_qty

            bank_coverage[bank_id] = {
                "matched_quantities": matched_quantities,
                "missing_quantities": missing_quantities,
                "total_matched": sum(matched_quantities.values()),
            }

        best_bank_id, best_bank_data = max(bank_coverage.items(), key=lambda x: x[1]["total_matched"])

        if not best_bank_data["missing_quantities"]:
            return BloodInventoryResponse.response_find_best_matching_bank(
                best_bank_id,
                best_bank_data["total_matched"],
                best_bank_data["matched_quantities"],
                None
            )

        for blood_part_key, missing_qty in best_bank_data["missing_quantities"].items():
            blood_part_id, blood_group_id = map(int, blood_part_key.split("_"))
            request_record = db.session.query(BloodPartRequest).filter_by(
                request_blood_id=request_blood_id,
                blood_part_id=blood_part_id,
                blood_group_id=blood_group_id
            ).first()

            if request_record:
                request_record.quantity -= missing_qty

        db.session.commit()

        return BloodInventoryResponse.response_find_best_matching_bank(
            best_bank_id,
            best_bank_data["total_matched"],
            best_bank_data["matched_quantities"],
            best_bank_data["missing_quantities"]
        )

    except Exception as e:
        db.session.rollback()
        return ErrorHandler.handle_error(e, message="Failed to find the best matching bank", status_code=500)

Додаток Б


@staticmethod
def process_supply_to_inventory(supply_id):
    try:
        supply = Supply.query.get(supply_id)
        blood_bank_id = supply.blood_bank_id
        supply_details_records = SupplyDetails.get_details_by_supply_id(supply_id)
        blood_parts = BloodPart.query.all()
        total_blood_inventory_records = 0

        for record in supply_details_records:
            for part in blood_parts:
                expiry_date = record.creation_date + timedelta(days=part.shelf_life_days)

                new_inventory = BloodInventory(
                    blood_bank_id=record.supply.blood_bank_id,
                    blood_part_id=part.blood_part_id,
                    creation_date=record.creation_date,
                    expiry_date=expiry_date,
                    blood_group_id=record.blood_group_id
                )
                db.session.add(new_inventory)
                db.session.commit()

            total_blood_inventory_records += 1
        for part in blood_parts:
            quantity = total_blood_inventory_records
            BloodTransaction.create_transaction(
                transaction_type="incoming",
                supply_id=supply_id,
                blood_part_id=part.blood_part_id,
                quantity=quantity,
                blood_bank_id=blood_bank_id,
            )
        return {"message": f"Successfully processed {total_blood_inventory_records * len(blood_parts)} blood inventory records"}, 200

    except Exception as e:
        db.session.rollback()
        return ErrorHandler.handle_error(e, message="Failed to processed blood", status_code=500)

Додаток В

@staticmethod
def process_request(blood_bank_id, request_blood_id):
    try:
        blood_parts = BloodPart.query.all()
        blood_part_requests = BloodPartRequest.query.filter_by(request_blood_id=request_blood_id).all()
        total_blood_inventory_records = 0

        request = BloodRequest.query.get(request_blood_id)
        if not request:
            return ErrorHandler.handle_error(None, message="Blood request not found", status_code=404)

        request.blood_bank_id = blood_bank_id
        request.status = "inprogress"
        db.session.commit()

        for blood_part_request in blood_part_requests:
            quantity_to_remove = blood_part_request.quantity
            blood_part_id = blood_part_request.blood_part_id
            blood_group_id = blood_part_request.blood_group_id

            inventory_records = db.session.query(BloodInventory).filter(
                BloodInventory.blood_bank_id == blood_bank_id,
                BloodInventory.blood_part_id == blood_part_id,
                BloodInventory.blood_group_id == blood_group_id,
            ).order_by(BloodInventory.creation_date.asc()).all()

            removed_records_count = 0

            for inventory in inventory_records:
                if quantity_to_remove <= 0:
                    break

                db.session.delete(inventory)
                quantity_to_remove -= 1
                removed_records_count += 1

            if quantity_to_remove > 0:
                db.session.rollback()
                return ErrorHandler.handle_error(
                    None,
                    message=f"Not enough blood inventory for blood part ID {blood_part_id}. Missing {quantity_to_remove} units.",
                    status_code=400
                )

            BloodTransaction.create_transaction(
                transaction_type="outgoing",
                request_blood_id=request_blood_id,
                blood_part_id=blood_part_id,
                quantity=removed_records_count,
                blood_bank_id=blood_bank_id,
            )

            total_blood_inventory_records += removed_records_count

        db.session.commit()

        return {"message": "Blood request processed successfully"}, 200
    except Exception as e:
        db.session.rollback()
        return ErrorHandler.handle_error(e, message="Failed to process blood request", status_code=500)




